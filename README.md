# StreamCommunication

StreamCommunication is a sample program meant to show how to make programs communicate via `stdin` and `stdout`.

I got inspired by this year's [aichallenge](http://aichallenge.org/), an online competition for programmers where contendent's provided _bots_ (programs) challenge each other in a virtual arena. 

I provide a host written in Java and some _bots_ written in various languages I use.

The host "loads" the bots (spawns two processes with the provided bots) and handle their input and output.

## The mighty communication protocol

To keep things simple, the task that the bots have to accomplish (and the protocol used) is very simple. Each protocols responds to 4 "questions": `ready?`, `bye!`, `generate code` and `find code`.

`ready?` -> must reply with `ready!`
`bye!` -> must reply with `bye!` and exit
`generate code` -> must output 5 lines of each with 5 dots and one randomly placed sharp. Examples of valide codes:

     .....     .....     .....     .....     ...#.
     ...#.     .....     .....     .....     .....
     .....     .....     .....     ..#..     .....
     .....     .#...     .....     .....     .....
     .....     .....     ....#     .....     .....

`find code` -> must read the following 5 lines from `stdin` and write the position of the sharp for the provided code (top-left is `0 0`). The correct answers for the previous codes are hence: `3 1`, `1 3`, `4 4`, `2 2` and `3 0`.

## Compiling and running the host

    ant compile jar
    
This creates `build/jar/Host.jar`. To make to bots communicate, simply provide the commands to launch them, for example:

    java -jar build/jar/Host.jar "./cbot" "python pythonbot.py"

`runhost.sh` and `runhost.bat` would compile and execute a sample bot for you (if python is installed).
    
You can experiment with your own bots or take a look at the sample ones I've written (keep reading).

Once executed, Host will output what's going on and any error generated by the bots. Sample output:
    
    Bot 1 ready!
    Bot 2 ready!
    Generated code:
    ....#
    .....
    .....
    .....
    .....
    Bot 2 found the right code [4 0]!
    Waving bots goodbye...
    Everything went as expected. Good job!

## How it all works

The Host program, given two bots as arguments, launches two processes. Let's call them `bot1` and `bot2`. Then:
1. Sends `ready?` to both `bot1` and `bot2` and waits for `ready!` as reply.
2. Sends `generate code` to `bot1` and reads the following 5 lines output by it
3. Checks if that the generated code is valid and finds the position on sharp
4. Sends `find code` and the five lines of `bot1`'s code to `bot2`.
5. Reads `bots`'s answer to find code and checks if it matches with what found.
6. Sends `bye!` to both `bot1` and `bot2` and waits for `bye!` in response.
        
## Bots

As a general note, if you launch the bots from withing a script (like in `runhost.sh`), you may encounter a problem with the bot writing to `stdout` but its stdout kept from being flushed. To overcome this problem, where possible, I forced the flush of standard output.

I mostly rushed the bots out and my knowled of the various programming languages I used it varied, so some solution may be more elegant than other (even if I moslty just rewrote the same program over and over trying to include programming languages peculiarities). Feel free to contribute better solutions!

### Bash

Plain Unix bash script. Launch it with `./bashbot.sh`.

### C

Doesn't have any non-standard library dependance. Compile it with `gcc cbot.cc -o cbot` and launch it with `./cbot`.

### C++

Doesn't have any non-standard library dependance. Compile it with `g++ cppbot.cpp -o cppbot` and launch it with `./cppbot`.

### Clojure

You can launch it with `java -cp clojure.jar clojure.main clojurebot.clj` or make a Leiningen project and launch it 
with `lein run` or compile it as a jar with `lein uberjar` and use it as a regular jar file.

### Coffeescript

This is a one to one port of Node.js script, suffering from the same limitations. See Node.js

### Common Lisp

Just run it with `clisp clispbot.cl`.

### C#

You can compile it with `csc.exe /out:csharpbot.exe csharpbot.cs` and simply run it as any `.exe` file. I haven't tested it with Mono, but it should work out of the box.

### F#

You can compile it with `fsc.exe /out:csharpbot.exe csharpbot.cs` and simply run it as any `.exe` file. I haven't tested it with Mono, but it should work out of the box.

### Groovy

Can be run with `groovy groovybot.groovy` or `java groovy.lang.GroovyShell groovybot.groovy`.

### Haskell

Compile it with `ghc -o haskellbot haskellbot.hs` or run it with `ghc haskellbot.hs`.

### Java

Compile it with `javac JavaBot.java` and run it with `java JavaBot`, as usual.

### Lua

Run it with `lua luabot.lua`

### Node.js

This version doesn't work. Because of the asynchronous nature of Node, I couldn't "stop 'n wait" for the output to flush and hence this _bot_ suffers from the flush problem. I've been advised to use the library [streamlinejs](https://github.com/Sage/streamlinejs), but I haven't tried it yet.

### Objective C

You can either create a command line XCode solution around the file and just let it compile it, or try to compile it from the cli with `gcc main.m -o main -ObjC -framework Foundation`.

### OCaml

Run it with `ocaml ocamlbot.cl`.

### Perl

Run it with `perl perlbot.pl`.

### Powershell

This hasn't been tested throughoutly. Microsoft pretends you to _register_ any script before running it or lower the overall security level. Then powershell scripting doesn't work with MS native scripting and couldn't be launched from within the dos batch I was using for testing. I just got bored and stop testing it. The code should work, by the way (if you manage to just run it!).

### Python

Run it with `python pybot.py`.

### Racket (Scheme)

Load the file in DrRacket and compile it.

### Ruby

Run it with `ruby rubybot.rb`. Thanks to `sort_by { rand }` and `each_slice(N)` this is, I think, the most compact solution.

### Scala

Either run it with `scala ScalaBot.scala` or compile it to a standard java class with `scalac ScalaBot.scala`.

### Tcl

Execute with `tclsh tclbot.tcl`